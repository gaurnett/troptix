import { useEffect, useMemo } from 'react';
import { Easing, interpolateColor, runOnJS, useAnimatedProps, useDerivedValue, useSharedValue, withDelay, withTiming } from 'react-native-reanimated';
import useCircleValues from './useCircleValues';
export default function useAnimatedValue(_ref) {
  let {
    initialValue = 0,
    radius = 60,
    maxValue = 100,
    clockwise,
    delay = 0,
    value,
    duration,
    onAnimationComplete = () => null,
    activeStrokeWidth = 10,
    inActiveStrokeWidth = 10,
    progressFormatter = v => {
      'worklet';

      return Math.round(v);
    },
    strokeColorConfig = undefined
  } = _ref;
  const animatedValue = useSharedValue(initialValue);
  const {
    circleCircumference
  } = useCircleValues({
    radius,
    activeStrokeWidth,
    inActiveStrokeWidth
  });
  const sortedStrokeColors = useMemo(() => {
    if (!strokeColorConfig) {
      return null;
    }

    return strokeColorConfig.sort((a, b) => a.value - b.value);
  }, [strokeColorConfig]);
  const colors = useMemo(() => {
    if (!sortedStrokeColors) {
      return null;
    }

    return sortedStrokeColors.map(item => item.color);
  }, [sortedStrokeColors]);
  const values = useMemo(() => {
    if (!sortedStrokeColors) {
      return null;
    }

    return sortedStrokeColors.map(item => item.value);
  }, [sortedStrokeColors]);
  const animatedCircleProps = useAnimatedProps(() => {
    let biggestValue = Math.max(initialValue, maxValue);
    biggestValue = biggestValue <= 0 ? 1 : biggestValue;
    const maxPercentage = clockwise ? 100 * animatedValue.value / biggestValue : 100 * -animatedValue.value / biggestValue;
    const config = {
      strokeDashoffset: circleCircumference - circleCircumference * maxPercentage / 100
    };
    const strokeColor = colors && values ? interpolateColor(animatedValue.value, values, colors) : undefined;

    if (strokeColor) {
      config.stroke = strokeColor;
    }

    return config;
  });
  useEffect(() => {
    animatedValue.value = withDelay(delay, withTiming(value, {
      duration,
      easing: Easing.linear
    }, isFinished => {
      if (isFinished) {
        var _runOnJS;

        (_runOnJS = runOnJS(onAnimationComplete)) === null || _runOnJS === void 0 ? void 0 : _runOnJS();
      }
    })); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [value]);
  const progressValue = useDerivedValue(() => {
    return `${progressFormatter(animatedValue.value)}`;
  });
  const animatedTextProps = useAnimatedProps(() => {
    return {
      text: progressValue.value // eslint-disable-next-line @typescript-eslint/no-explicit-any

    }; // eslint-disable-line prettier/prettier
  });
  return {
    animatedCircleProps,
    animatedTextProps,
    progressValue
  };
}
//# sourceMappingURL=useAnimatedValue.js.map